<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<body>

<script th:fragment="chat-widget-scripts">

    class PrivateMessageWebsocket {

    constructor(currentUserName, onMessageReceived){
        this.currentUserName = currentUserName,
        this.onMessageReceived = onMessageReceived,
        this.stompClient = null;
        this.connected = false;
    }

    async getTokenFromCookie(){
        
        const URI_TOKEN = '/api/auth/gettoken';

        try{
            const response = await fetch(URI_TOKEN, {
                method: 'GET',
                headers: {
                    'Content-Type':'application/json'
                }
            });

            if(!response.ok){
                throw new Error('인증 토큰을 가져오는데 실패했습니다.');
            }

            const data = await response.json();

            return data.Authorization;

        }catch(error){

            console.error('WebSocket 토큰 획득 오류 : ', error);
            return null;
        }
    }

    async connect(){

        const token = await this.getTokenFromCookie();

        if(!token){
            console.error('❌ 토큰 없음. 1:1 채팅 연결 실패.');
            return;
        }

        const headers = {
            'Authorization':`Bearer ${token}`
        }

        const socket = new SockJS("/ws");
        this.stompClient = Stomp.over(socket);
        this.stompClient.debug = null;

        this.stompClient.connect(headers, (frame)=> {

            console.log("✅ [PrivateMessage] STOMP 연결 성공");
            this.connected = true;
            
            if (!this.stompClient || !this.stompClient.connected) {
                console.error('STOMP 클라이언트가 연결되지 않았습니다.');
                return;
            }

            this.stompClient.subscribe('/user/queue/messages', (message) => {
                console.log('✉️ [PrivateChat] 개인 메시지 수신');
                const privateMessage = JSON.parse(message.body);
                if(typeof this.onMessageReceived === 'function'){

                    this.onMessageReceived(privateMessage);

                    console.log('✅ [PrivateMessage] 개인 큐 구독 완료: /user/queue/messages');
                }

                const activePartner = document.getElementById('chat-header').dataset.partner;

                if(privateMessage.senderUsername === activePartner){
                    this.stompClient.send("/app/messages/read", {}, JSON.stringify({
                        partnerUsername : activePartner
                    }));
                }
            });

            this.stompClient.subscribe('/user/queue/messagelist-update', onConversationUpdateReceived);

            console.log('✅ [ChatList] 채팅 목록 업데이트 큐 구독 완료');
            
            this.stompClient.subscribe('/user/queue/notification', onNotificationReceived);

            console.log('✅ [notification] 메시지 알림 구독 완료');
            
            this.stompClient.subscribe('/user/queue/total-unread', (message) => {

                const newCount = message.body;

                console.log('✅ [Badge] 뱃지 업데이트 신호 수신:', message.body);

                updateUnreadBadge(newCount);

            })

            fetch('/api/private/messages/unread/total') 
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Initial count fetch failed');
                    }
                    return response.json();
                })
                .then(count => {
                    updateUnreadBadge(count);
                })
                .catch(error => {
                    console.error("초기 전체 읽지 않은 메시지 카운트 로딩 실패:", error);
                });

        }, (error)=> {
                console.error("❌ [PrivateMessage] WebSocket 연결 실패:", error);
                this.connect = false;
        });
    }

    subscribePrivateQueue(){        
    }

    sendPrivateMessage(receiverUsername, content){
        if(!this.connected){
            console.error('❌ [PrivateMessage] 연결 안 됨. 메시지 전송 불가.')
            return;
        };

        const messagePayload = JSON.stringify({
            receiverUsername: receiverUsername,
            content: content
        });

        this.stompClient.send("/app/private/message", {}, messagePayload);
    }
}

window.currentChatPartner = null;
window.currentPartnerName = null;
window.privateMessageWsClient = null;

function handleReceivedMessage(message){
    console.log(`[채팅 위젯] 새 메시지: ${message.senderUsername} -> ${message.content}`);

    if(message.senderUsername === window.currentChatPartner || message.receiverUsername === window.currentChatPartner){

        displayMessageInHistory(message);
    }
}

async function fetchAndRenderPartnerList(){

    try{
        const response = await fetch('/api/private/messages/conversations');

        if(!response.ok){
            throw new Error('파트너 목록을 가져오는 데 실패했습니다.');
        }

        const partnerList = await response.json();

        renderConversationList(partnerList);

    }catch(error){
        console.error('error : ', error);
    }
}

function renderConversationList(partnerList){

    const listContainer = document.getElementById('candidate-list');

    if(!listContainer){
        console.error('채팅 목록을 표시할 요소를 찾을 수 없습니다.');
        return;
    }

    let newHtml = '';
    listContainer.innerHTML = '';

    partnerList.forEach(partner => {
        
        const unreadCount = partner.unreadCount;
        const lastContent = partner.lastMessageContent || '대화 시작';
        const lastTime = partner.lastMessageSentAt ? new Date(partner.lastMessageSentAt).toLocaleTimeString() : '';
        const badgeHtml = unreadCount > 0 
            ? `<span id="unread-badge-${partner.partnerUsername}" class="badge">${partner.unreadCount}</span>`
            : '';
        const displayName = partner.partnerName || partner.partnerUsername;

        newHtml += `
            <li class="candidate-item" onclick="openMessageWindow('${partner.partnerUsername}', '${displayName}')">
                <div class="info-text-area">
                    <span class="name">${displayName}</span>
                    <span class="last-message-snippet">${lastContent.substring(0,30)}...</span>
                </div>
                <div class="status-area">
                    <span class="message-time">${lastTime}</span>
                    ${badgeHtml}
                </div>                
            </li>    
        `;
    });

    listContainer.innerHTML = newHtml;
}

function onConversationUpdateReceived(payload){
    const updatedList = JSON.parse(payload.body);
    renderConversationList(updatedList);
}

async function fetchMessageHistory(partnerUsername){

    const API_BASE_URL = window.location.origin;
    const API_URL = `${API_BASE_URL}/api/private/messages/${encodeURIComponent(partnerUsername)}`;

    try {
        const response = await fetch(API_URL, {
            method: 'GET',
            credentials: 'include'
        });

        if(!response.ok){
            throw new Error(`메시지 내역 로딩 실패 : HTTP ${response.status}`);
        }

        const history = await response.json();
        console.log(`✅ ${partnerUsername}과의 메시지 내역 ${history.length}개 조회`);
        return history;        
        
    }catch(error){
        console.error('❌ 메시지 내역 조회 중 네트워크 오류 발생:', error);
        throw error;
    }
}

async function openMessageWindow(partnerUsername, partnerName){

    const API_BASE_URL = window.location.origin;
    const RESTORE_URL = `${API_BASE_URL}/api/private/messages/restore/${encodeURIComponent(partnerUsername)}`;

    try{
        await fetch(RESTORE_URL, {method: 'POST'});
        console.log(`대화방 상태 복구 완료 : ${partnerUsername}`);
    }catch(e){
        console.error("대화방 상태 복구 실패", e);
    }

    const container = document.getElementById('chat-widget-container');
    const toggleBtn = document.getElementById('chat-toggle-btn');
    const chatSidebar = document.getElementById('chat-sidebar');
    const chatMain = document.getElementById('chat-main');

    if(!container || !toggleBtn){
        console.error("위젯 요소를 찾을 수 없습니다.");
        return;
    }

    const chatHeader = document.getElementById('chat-header');
    const messageHistory = document.getElementById('message-history');
    const sendBtn = document.getElementById('send-btn');

    container.classList.add('active');
    toggleBtn.classList.add('hidden-by-widget');

    if(window.innerWidth <= 768) {
        if(chatSidebar) chatSidebar.classList.add('hidden-mobile');
        if(chatMain) chatMain.classList.remove('hidden-mobile');
    }

    const displayName = partnerName || partnerUsername;
    window.currentPartnerName = displayName;

    if(chatHeader){

        const headerTitle = chatHeader.querySelector('h4');
        const exitBtn = document.getElementById('exitConversation');

        if(headerTitle){
            headerTitle.innerHTML = `${displayName}님과 대화중`; 
        }
        
        if(exitBtn){
            exitBtn.classList.remove('hidden');
        }

        chatHeader.dataset.partner = partnerUsername;
    }

    messageHistory.innerHTML = '';

    window.currentChatPartner = partnerUsername;
    sendBtn.disabled = false;

    try{
        const history = await fetchMessageHistory(partnerUsername);

        history.forEach(msg => displayMessageInHistory(msg));

        messageHistory.scrollTop = messageHistory.scrollHeight;

        const response = await fetch(`/api/private/messages/read/${partnerUsername}`, {
            method : 'PUT',    
            headers: {'Content-Type' : 'application/json'},
        });

        if(response.ok){
            console.log(`[Read Status] ${partnerUsername}과의 대화를 읽음 처리 완료`);
            clearLocalUnreadBadge(partnerUsername);
        }else{
            console.error(`[Read Status] 서버 응답 오류 : `, response.status);
        }

    }catch(error){
        console.error('채팅방 열기 중 오류 발생:', error);
        messageHistory.innerHTML = '<div class="error-message">메시지 내역을 불러오는데 실패했습니다.</div>';
    }

    if(!window.privateMessageWsClient.connected){
        window.privateMessageWsClient.connect();
    }
}

function showChatList() {
    const chatSidebar = document.getElementById('chat-sidebar');
    const chatMain = document.getElementById('chat-main');
    const chatHeader = document.getElementById('chat-header');
    const exitBtn = document.getElementById('exitConversation');
    
    if(chatSidebar) {
        chatSidebar.classList.remove('hidden-mobile');
    }
    if(chatMain && window.innerWidth <= 768) {
        chatMain.classList.add('hidden-mobile');
    }
    
    window.currentChatPartner = null;
    window.currentPartnerName = null;
    
    if(chatHeader) {
        chatHeader.removeAttribute('data-partner');
        const headerTitle = chatHeader.querySelector('h4');
        if(headerTitle) {
            headerTitle.innerHTML = '[대화 상대를 선택하세요]';
        }
    }
    if(exitBtn) {
        exitBtn.classList.add('hidden');
    }
    
    const messageHistory = document.getElementById('message-history');
    if(messageHistory) {
        messageHistory.innerHTML = '';
    }
}

async function exitConversation(partnerUsername){

    const API_BASE_URL = window.location.origin;
    const API_URL = `${API_BASE_URL}/api/private/messages/exit/${encodeURIComponent(partnerUsername)}`;

    try {
        const response = await fetch(API_URL, {method: 'POST'});

        if(response.ok){
            alert(`${window.currentPartnerName || partnerUsername}님과의 대화방을 나갔습니다.`);
            if(window.innerWidth <= 768) {
                showChatList();
            } else {
                closeChatWidget();
            }
        }else{
            alert('대화방 나가기 실패');
        }

    } catch (error) {
        console.error('대화방 나가기중 에러 : ', error);
        alert('서버 연결 오류');
    }
}

function closeChatWidget(){
    const container = document.getElementById('chat-widget-container');
    const toggleBtn = document.getElementById('chat-toggle-btn');
    const chatSidebar = document.getElementById('chat-sidebar');
    const chatMain = document.getElementById('chat-main');
    const chatHeader = document.getElementById('chat-header');
    const searchInput = document.getElementById('candidate-search');

    if(searchInput && searchInput.value.trim() !== ''){
        searchInput.value = '';
        fetchAndRenderPartnerList();
    }

    window.currentChatPartner = null;
    window.currentPartnerName = null;

    if(chatHeader){
        chatHeader.removeAttribute('data-partner');
        const headerTitle = chatHeader.querySelector('h4');
        if(headerTitle){
            headerTitle.textContent = '[대화 상대를 선택하세요]';
        }
    }

    const messageHistory = document.getElementById('message-history');
    if(messageHistory){
        messageHistory.innerHTML = '';
    }

    const exitBtn = document.getElementById('exitConversation');
    if(exitBtn){
        exitBtn.classList.add('hidden');
    }

    if(container){
        container.classList.remove('active');
    }
    if(toggleBtn){
        toggleBtn.classList.remove('hidden-by-widget');
    }
    if(chatSidebar){
        chatSidebar.classList.remove('hidden-mobile');
    }
    if(chatMain){
        chatMain.classList.remove('hidden-mobile');
    }
}

function clearLocalUnreadBadge(partnerUsername){
    const badgeElement = document.getElementById(`unread-badge-${partnerUsername}`);

    if(badgeElement){
        badgeElement.textContent = '0';
        badgeElement.style.display = 'none';
    }
}

function showToast(title, body, senderUsername){
    const toastContainer = document.getElementById('toast-container');

    if(!toastContainer){
        console.error('Toast container not found');
        return;
    }

    const toast = document.createElement('div');
    toast.classList.add('toast-notification');

    toast.onclick = () => {
        openMessageWindow(senderUsername, null);
        toast.remove();
    };

    toast.innerHTML = `
        <div class="toast-title">${title}</div>
        <div class="toast-body">${body}</div>
    `;

    toastContainer.appendChild(toast);

    setTimeout(()=> {
        toast.classList.add('show');
    }, 10);

    setTimeout(()=> {
        toast.classList.remove('show');
        toast.addEventListener('transitionend', () => toast.remove());
    }, 3000);
}

function onNotificationReceived(payload){

    const notificationData = JSON.parse(payload.body);

    const sender = notificationData.senderUsername;
    const content = notificationData.messageSnippet;

    const chatHeader = document.getElementById('chat-header');
    const currentPartner = chatHeader ? chatHeader.dataset.partner : null;

    const chatWidgetContainer = document.getElementById('chat-widget-container');
    const isChatWidgetOpen = chatWidgetContainer && chatWidgetContainer.classList.contains('active');

    if(isChatWidgetOpen && currentPartner === sender){
        console.log('현재 대화중인 상대방의 메시지이므로 알림 스킵');
        return;
    }
    
    showToast(`${sender}님에게 새 메시지가 도착했습니다.`, content, sender);
}

function displayMessageInHistory(message){

    const messageHistory = document.getElementById('message-history');
    const myUsername = getCurrentUsername();

    const isMe = message.senderUsername === myUsername;

    const messageElement = document.createElement('div');
    messageElement.className = isMe ? 'message-container sender' : 'message-container receiver';

    const senderName = isMe ? '나' : (message.senderName || message.senderUsername);
    const time = new Date(message.sentAt).toLocaleTimeString('ko-KR', {hour: '2-digit', minute: '2-digit'});
    messageElement.innerHTML = `
        <div class="sender-name">${senderName}</div>
        <div class="message-bubble">${message.content}</div>
        <div class="message-item" style="font-size : 12px;">${time}</div>
    `

    messageHistory.appendChild(messageElement);
    messageHistory.scrollTop = messageHistory.scrollHeight;
}

function setupMessageEvents(){
    const sendBtn = document.getElementById('send-btn');
    const messageInput = document.getElementById('message-input');

    const handleSendMessage = () => {
        const content = messageInput.value.trim();
        const receiverUsername = window.currentChatPartner;
        
        if(content && receiverUsername && window.privateMessageWsClient){

            window.privateMessageWsClient.sendPrivateMessage(receiverUsername, content);

            const sentMessage = {
                senderUsername: getCurrentUsername(),
                content: content,
                sentAt: new Date().toISOString()
            };

            displayMessageInHistory(sentMessage);
            messageInput.value = '';
        }
    };

    sendBtn.addEventListener('click', handleSendMessage);
    messageInput.addEventListener('keypress', (e)=>{
        if(e.key === 'Enter' && !e.shiftKey){
            e.preventDefault();
            handleSendMessage();
        }
    });

    sendBtn.disabled = true;
}

function debounce(func, delay){
    let timeout;
    return function(...args){
        clearTimeout(timeout);
        timeout = setTimeout(()=> func.apply(this, args), delay);
    }
}

function setupSearchHandler(){
    const searchInput = document.getElementById('candidate-search');
    searchInput.addEventListener('input', debounce(handleSearchInput, 300));
}

function handleSearchInput(event){
    const query = event.target.value.trim();

    if(query.length > 1){
        fetchSearchUsers(query);
    }else{
        fetchAndRenderPartnerList();
    }    
}

async function fetchSearchUsers(query){

    const API_BASE_URL = window.location.origin;
    const API_URL = `${API_BASE_URL}/api/users/search?q=${encodeURIComponent(query)}`;

    try {
        const response = await fetch(API_URL, {
            method: 'GET',
            headers: {
                'Content-Type':'application/json'
            }
        });

        if(!response.ok){
            throw new Error(`HTTP 에러 : ${response.status}`);
        }

        const users = await response.json();
        handleSearchResults(users);

    }catch(error){
        console.error('사용자 검색 실패', error);
    }
}

function handleSearchResults(users){
    
    const candidateList = document.getElementById('candidate-list');
    candidateList.innerHTML = '';

    if(users.length === 0){
        return;
    }

    users.forEach(user => {
        const item = createCandidateItem(user);
        candidateList.appendChild(item);
    });
}

function createCandidateItem(user){

    const listItem = document.createElement('li');
    listItem.className = 'candidate-item';
    listItem.setAttribute('data-username', user.username);
    listItem.setAttribute('data-name', user.name);

    listItem.innerHTML = `
        <span class="name">${user.name} (${user.username})</span>
        <span class="status online">●</span><span class="badge hidden">0</span>
    `;

    listItem.addEventListener('click', handleCandidateClick);
    return listItem;
}

function handleCandidateClick(event){

    const listItem = event.currentTarget;
    const targetUsername = listItem.getAttribute('data-username');
    const targetName = listItem.getAttribute('data-name');

    if(targetUsername){
        console.log(`[클릭] ${targetName || targetUsername}와의 채팅방을 엽니다.`);
        window.currentChatPartner = targetUsername;
    }

    openMessageWindow(targetUsername, targetName);
}

function setupWidgetToggle(){

    const toggleBtn = document.getElementById('chat-toggle-btn');
    const container = document.getElementById('chat-widget-container');
    const closexBtn = document.querySelector('.close-x-btn');
    const backBtn = document.getElementById('back-btn');

    if(!toggleBtn || !container){
        console.error("채팅 위젯의 HTML 요소를 찾을 수 없습니다.");
        return;
    }

    toggleBtn.addEventListener('click', ()=>{

        const isActive = container.classList.toggle('active');

        if(isActive){
            toggleBtn.classList.add('hidden-by-widget');

            const chatHeader = document.getElementById('chat-header');
            const exitBtn = document.getElementById('exitConversation');
            const currentPartner = chatHeader ? chatHeader.dataset.partner : null;

            if (exitBtn) {
                if (currentPartner) {
                    exitBtn.classList.remove('hidden');
                } else {
                    exitBtn.classList.add('hidden');
                }
            }
        }else{
            toggleBtn.classList.remove('hidden-by-widget');
        }
    });

    if(closexBtn){
        closexBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            closeChatWidget();
        });
    }

    if(backBtn){
        backBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            showChatList();
        });
    }
}

function updateUnreadBadge(count){

    const unreadBadge = document.getElementById('unread-badge');
    const totalCount = parseInt(count) || 0;

    unreadBadge.textContent = totalCount;

    if (totalCount > 0) {
        unreadBadge.classList.remove('hidden');
    } else {
        unreadBadge.classList.add('hidden');
    }
}

function getCurrentUsername(){

    const hiddenInputField = document.getElementById('current-user-username-data');

    if(hiddenInputField && hiddenInputField.dataset.username){
        return hiddenInputField.dataset.username;
    }

    return null;
}

document.addEventListener('DOMContentLoaded', ()=>{
      
    const myUsername = getCurrentUsername();
    const closexBtn = document.querySelector('.close-x-btn');
    const exitBtn = document.getElementById('exitConversation');

    if(exitBtn){
        exitBtn.addEventListener('click',()=>{
            const chatHeader = document.getElementById('chat-header');
            const partner = chatHeader ? chatHeader.dataset.partner : null;

            if(partner){
                exitConversation(partner);
            }else{
                alert('대화 상대를 찾을 수 없습니다.');
            }
        });
    }

    if(closexBtn){
        closexBtn.addEventListener('click', closeChatWidget);
    }

    if(myUsername){
        
        window.privateMessageWsClient = new PrivateMessageWebsocket(myUsername, handleReceivedMessage);
        window.privateMessageWsClient.connect();
        fetchAndRenderPartnerList();
        setupSearchHandler();
        setupWidgetToggle();
        setupMessageEvents();

    }else{
        console.warn("사용자 정보 없음. 채팅 위젯을 비활성화합니다.");
    }
});

</script>

</body>
</html>
